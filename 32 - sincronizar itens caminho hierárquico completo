Imports Inventor
Imports System.Windows.Forms
Imports System.Text
Imports System.Linq

' iLogic – Inventor: Sincroniza Item Numbers de submontagens com base no BOM hierárquico
' Compatível com Inventor 2020+
' Autor: ChatGPT (refatorado com hierarquia única)
' Última revisão: 2025-11-04

Sub Main()

    ' === CONFIGURAÇÕES DE SINCRONIZAÇÃO ===
    Const MANTER_PAI_IMUTAVEL As Boolean = True

    Dim doc As Document = ThisApplication.ActiveDocument
    If doc Is Nothing OrElse doc.DocumentType <> DocumentTypeEnum.kAssemblyDocumentObject Then
        MessageBox.Show("Abra uma montagem antes de rodar esta regra.", "Documento inválido", MessageBoxButtons.OK, MessageBoxIcon.Warning)
        Return
    End If

    Dim asmDoc As AssemblyDocument = CType(doc, AssemblyDocument)
    Dim mapaGlobal As List(Of Tuple(Of String, String, String)) = ObterMapaCompleto(asmDoc)

    If mapaGlobal.Count = 0 Then
        MessageBox.Show("Nenhum item encontrado no BOM estruturado da montagem.", "Aviso", MessageBoxButtons.OK, MessageBoxIcon.Information)
        Return
    End If

    ' Sincroniza montagem principal apenas se permitido
    If Not MANTER_PAI_IMUTAVEL Then
        Dim mapaLocal As Dictionary(Of String, String) = ObterMapaLocal(asmDoc)
        SincronizarItemNumbers(mapaGlobal, mapaLocal, asmDoc, asmDoc.DisplayName)
    End If

    ' Sincroniza submontagens recursivamente
    SincronizarSubmontagensRecursivo(asmDoc, mapaGlobal)

    ' Salva montagem principal
    Try : asmDoc.Save2(True) : Catch : End Try

    ' Exibe resultado
    ShowFormattedResults(FormatarMapaParaTexto(mapaGlobal))
    MessageBox.Show("Sincronização concluída com sucesso!", "Sucesso", MessageBoxButtons.OK, MessageBoxIcon.Information)

End Sub


' === Mostrar painel com resultado da execução ===
Private Sub ShowFormattedResults(message As String)
    Dim form As New Form With {.Text = "RESULTADO DA SINCRONIZAÇÃO", .Width = 1000, .Height = 600}
    Dim richText As New RichTextBox With {.Dock = DockStyle.Fill, .ReadOnly = True}
    richText.AppendText("MAPA DE SINCRONIZAÇÃO:" & vbCrLf & vbCrLf & message)
    form.Controls.Add(richText)
    form.ShowDialog()
End Sub


' === Formata a lista em texto legível ===
Private Function FormatarMapaParaTexto(mapa As List(Of Tuple(Of String, String, String))) As String
    Dim sb As New StringBuilder()

    Dim col1Width As Integer = 60 ' PART NUMBER
    Dim col2Width As Integer = 15 ' ITEM NUMBER

    sb.AppendLine("PART NUMBER".PadRight(col1Width) & "ITEM NUMBER".PadRight(col2Width) & "CAMINHO HIERÁRQUICO")
    sb.AppendLine(New String("-"c, col1Width + col2Width + 70))

    For Each item In mapa
        sb.AppendLine(item.Item1.PadRight(col1Width) & item.Item2.PadRight(col2Width) & item.Item3)
    Next

    Return sb.ToString()
End Function


' === Gera mapa completo a partir do BOM estruturado (com hierarquia e nomes únicos) ===
Private Function ObterMapaCompleto(asm As AssemblyDocument) As List(Of Tuple(Of String, String, String))
    Dim mapa As New List(Of Tuple(Of String, String, String))()

    Try
        Dim bom As BOM = asm.ComponentDefinition.BOM
        bom.StructuredViewEnabled = True
        bom.StructuredViewFirstLevelOnly = False

        Dim view As BOMView = bom.BOMViews _
            .Cast(Of BOMView)() _
            .FirstOrDefault(Function(v) v.ViewType = BOMViewTypeEnum.kStructuredBOMViewType)

        If view Is Nothing Then Return mapa

        For Each row As BOMRow In view.BOMRows
            AdicionarAoMapaRecursivo(row, mapa, asm.DisplayName)
        Next

    Catch ex As Exception
        MessageBox.Show("Erro ao construir mapa completo: " & ex.Message, "Erro", MessageBoxButtons.OK, MessageBoxIcon.Error)
    End Try

    Return mapa
End Function


' === Adiciona linhas ao mapa global com caminho hierárquico único (por ocorrência) ===
Private Sub AdicionarAoMapaRecursivo(row As BOMRow, mapa As List(Of Tuple(Of String, String, String)), parentPath As String)
    Try
        If row.ComponentDefinitions.Count = 0 Then Exit Sub

        Dim doc As Document = row.ComponentDefinitions.Item(1).Document
        Dim partNumber As String = ""
        Dim itemNumber As String = ""
        Dim occurrenceName As String = ""

        Try
            partNumber = doc.PropertySets.Item("Design Tracking Properties").Item("Part Number").Value.ToString()
        Catch
            partNumber = doc.DisplayName
        End Try

        Try
            itemNumber = row.ItemNumber
        Catch
            itemNumber = "-"
        End Try

        ' Obtém nome único da ocorrência
        Try
            occurrenceName = row.ReferencedFileDescriptor.DisplayName
        Catch
            occurrenceName = doc.DisplayName
        End Try

        ' Cria caminho hierárquico único
        Dim caminho As String = parentPath & "\" & occurrenceName & " [#" & itemNumber & "]"

        If Not String.IsNullOrEmpty(partNumber) AndAlso Not String.IsNullOrEmpty(itemNumber) Then
            mapa.Add(New Tuple(Of String, String, String)(partNumber, itemNumber, caminho))
        End If

        ' Processa filhos
        If row.ChildRows IsNot Nothing Then
            For Each child In row.ChildRows
                AdicionarAoMapaRecursivo(child, mapa, caminho)
            Next
        End If

    Catch
        ' Ignora erros individuais
    End Try
End Sub


' === Extrai o mapa local da montagem (nível atual) ===
Private Function ObterMapaLocal(assemblyDoc As AssemblyDocument) As Dictionary(Of String, String)
    Dim mapa As New Dictionary(Of String, String)(StringComparer.OrdinalIgnoreCase)

    Try
        Dim bom As BOM = assemblyDoc.ComponentDefinition.BOM
        bom.StructuredViewEnabled = True
        bom.StructuredViewFirstLevelOnly = True

        Dim view As BOMView = bom.BOMViews.Cast(Of BOMView)() _
            .FirstOrDefault(Function(v) v.ViewType = BOMViewTypeEnum.kStructuredBOMViewType)

        If view Is Nothing Then Return mapa

        For Each row As BOMRow In view.BOMRows
            Try
                If row.ComponentDefinitions.Count = 0 Then Continue For

                Dim doc As Document = row.ComponentDefinitions.Item(1).Document
                Dim partNumber As String = doc.PropertySets.Item("Design Tracking Properties").Item("Part Number").Value.ToString()
                Dim itemNumber As String = row.ItemNumber

                If Not mapa.ContainsKey(partNumber) AndAlso Not String.IsNullOrEmpty(itemNumber) Then
                    mapa.Add(partNumber, itemNumber)
                End If

            Catch
                Continue For
            End Try
        Next

    Catch ex As Exception
        Debug.Print("⚠️ Erro ao construir mapa local: " & ex.Message)
    End Try

    Return mapa
End Function


' === Sincroniza Item Numbers de uma montagem com base no mapa global ===
Private Sub SincronizarItemNumbers(mapaGlobal As List(Of Tuple(Of String, String, String)), mapaLocal As Dictionary(Of String, String), asm As AssemblyDocument, subPath As String)
    Try
        Dim bom As BOM = asm.ComponentDefinition.BOM
        bom.StructuredViewEnabled = True
        bom.StructuredViewFirstLevelOnly = True

        Dim view As BOMView = bom.BOMViews _
            .Cast(Of BOMView)() _
            .FirstOrDefault(Function(v) v.ViewType = BOMViewTypeEnum.kStructuredBOMViewType)

        If view Is Nothing Then Return

        ' Filtra o mapa para o contexto da submontagem
        Dim mapaFiltrado = mapaGlobal.Where(Function(t) t.Item3.Contains("\" & subPath)).ToList()

        For Each row As BOMRow In view.BOMRows
            Try
                If row.ComponentDefinitions.Count = 0 Then Continue For

                Dim doc As Document = row.ComponentDefinitions.Item(1).Document
                Dim partNumber As String = doc.PropertySets.Item("Design Tracking Properties").Item("Part Number").Value.ToString()
                Dim occurrenceName As String = ""
                Try
                    occurrenceName = row.ReferencedFileDescriptor.DisplayName
                Catch
                    occurrenceName = doc.DisplayName
                End Try

                ' Procura correspondência pelo caminho hierárquico completo
                Dim itemNumberPai As String = mapaFiltrado _
                    .Where(Function(t) t.Item3.EndsWith("\" & occurrenceName & " [#" & t.Item2 & "]")) _
                    .Select(Function(t) t.Item2) _
                    .FirstOrDefault()

                If Not String.IsNullOrWhiteSpace(itemNumberPai) AndAlso row.ItemNumber <> itemNumberPai Then
                    Try
                        row.ItemNumber = itemNumberPai
                    Catch
                        ' Ignora erro de escrita
                    End Try
                End If

            Catch
                ' Ignora erro na linha
            End Try
        Next

    Catch ex As Exception
        ' Silencia erros globais
    End Try
End Sub


' === Sincroniza submontagens recursivamente ===
Private Sub SincronizarSubmontagensRecursivo(asm As AssemblyDocument, mapaGlobal As List(Of Tuple(Of String, String, String)))
    Try
        For Each occ As ComponentOccurrence In asm.ComponentDefinition.Occurrences
            If occ.DefinitionDocumentType = DocumentTypeEnum.kAssemblyDocumentObject Then
                Try
                    Dim subDoc As Document = Nothing
                    Try
                        subDoc = ThisApplication.Documents.Item(occ.Definition.Document.FullFileName)
                    Catch
                        subDoc = ThisApplication.Documents.Open(occ.Definition.Document.FullFileName, False)
                    End Try

                    Dim subAsm As AssemblyDocument = TryCast(subDoc, AssemblyDocument)
                    If subAsm Is Nothing Then Continue For

                    Dim mapaLocalSub As Dictionary(Of String, String) = ObterMapaLocal(subAsm)
                    SincronizarItemNumbers(mapaGlobal, mapaLocalSub, subAsm, subAsm.DisplayName)

                    Try : subAsm.Save2(True) : Catch : End Try

                    ' Recursão profunda
                    SincronizarSubmontagensRecursivo(subAsm, mapaGlobal)

                Catch
                    ' Ignora erro individual
                End Try
            End If
        Next

    Catch
        ' Ignora falhas gerais
    End Try
End Sub
